Yingzhu Zhang 
CS304, hw6

1. Array
	M = 24
	N = 36
2. Set associative cache
	number of sets in the cache: S = C/(E*B)
	number of index bits in the address: log_2(S) = log_2(C/(E*B))
	number of bits for a tag: m-log_2(C/(E*B))-b
3. Cache dimensions
	a. 2^15
	b. tag, index, offsets
		i. 9-bit, 5-bit, 2-bit: 001101000 01101 00
		ii. 8-bit, 4-bit, 4-bit: 00110100 0011 0100
		iii. 6-bit, 7-bit, 3-bit: 001101 0000110 100
	c. write-back: 6/64, write-through: 5/64

â€¢	What is the ratio of data bits to total bits in a 128 byte write-back direct-mapped cache that has 8-byte blocks and byte addresses are 64 bits? What about if it were a write-through cache instead? 
	64/122	write-through
	64/123	write-back
	
4. Cache Accesses
	i. 100%
		Because we are looking at the cache activity generated by references to the array, therefore, we need to only consider the activity generated in the inner for loop first, find the pattern, then apply the pattern to the outer loop. For the inner loop, assume we start from address 0x000...000, the index is going to 0, 0, 0, 0. Therefore, we will always have cache miss, thus 100%.
	ii. 100%
		Suppose the starting address of the array is 0x1020, then at each array access, the cache index is going to be the same, therefore, we are going to have all misses in the inner loop. Thus, including the outer loop, our miss rate will be 100%.
5. Cachelab
	L3 = 20+5%*100=25
	L2 = 4+10%*25=6.5
	L1 = 1+20%*6.5=2.3
	2.3 cycles

